1. 数组和切片的区别与联系
    1.1 数组是有长度的并且长度是类型的组成部分之一 所以[1]string!=[2]string 长度固定不可变
    1.2 切片实际上是对底层数组的一层封装，通过切片的容量和长度 我们可以访问到底层数组中对应的元素,
        1.2.1 如果切片是从底层数组下标为0处开始引用 那个切片的第一个元素(下标为0时)引用的是数组下标为0的元素
        1.2.2 如果切片是从底层数组下标为3处开始引用那么切片的第一个元素(下标为0时)引用的是数组下标为3的元素
2. 数组和切片的共同点
   它们都是集合类型
3. 值传递和引用传递
   如果实参是值类型 就是值传递 如果实参为引用类型则是引用传递 一般来说引用传递更快更好
   go语言中值类型: 数组，和内置的数据类型 以及结构体
   go语言中引用类型: 切片(slice) 字典(map) 通道(channel) 函数(func) 是引用类型 引用类型一般使用make创建和初始化
4. 关于切片长度和容量的计算
   切片长度一般是对底层数组的引用范围 比如s1=s2[3:6] [3,6)引用范围为3-5所以长度为6-3=3，但是切片可以向右扩展而不能向左扩展 所以 s1的容量就 = s2的容量-3 3是对数组引用的起始下标 6是对数组引用的结束下标
5. 关于append和切片扩容
    一般使用append对切片进行追加元素 分为以下两种情况
    5.1. 追加过后元素长度小于容量
            append返回原切片
    5.2. 追加过后元素长度超过了容量
            5.2.1 如果长度小于1024
            则扩容机制为 新切片容量 = 原切片容量*2
            返回新切片地址
            5.2.2 如果长度大于1024
            则扩容机制为 新切片容量 = 原切片容量*1.25
            返回 新切片地址
            5.2.3 如果要追加的元素过多 比切片容量的两倍还多
            则再进行前面 2.1 2.2的操作
            重点 因为切片必定引用一个底层数组 所以数组也不会是原来的数组了
6. 切片的缩容
    回答到思考题当中
思考题答案
1. 如果多个切片引用到同一个数组应该注意什么
    这个问题 就像并发问题 多个线程同时操作一块内存区域 所以要注意的是 读写顺序 及读写过后的更新问题 避免本来想读老数据 却被另外一个切片给写入数据了
2. 切片缩容问题
   其实可以反向思考 扩容问题
   当切片的容量小于等于一定比例后 有大量的空间被浪费 所以新弄一个新切片 容量为原切片按比列缩小
   并返回新的切片