1.Mutex(互斥锁)
(1)不要重复锁定互斥锁；
(2)不要忘记解锁互斥锁，必要时使用defer语句；
(3)不要对尚未锁定或者已解锁的互斥锁解锁；
(4)不要在多个函数之间直接传递互斥锁。

2.RW_Mutex
(1)基本定义
-写写互斥
-写读互斥
-读写互斥
-读读不互斥
写锁方法阻塞所有方法
读锁方法阻塞所有写方法，读方法可以并发执行。

(2)场景
读多写少

(3)
-写优先,仅限定于新reader,如果在writer请求锁时,已有reader持有锁,仍然需要等待持有锁的reader释放锁

3. Cond
    3.1 条件变量: 依赖锁, 观察, 共享资源状态, 事件通知
    3.2 条件变量: 基于互斥锁的，它必须有互斥锁的支撑才能发挥作用
    3.3 三个方法: wait, signal, broadcast
    3.4 signal()和broadcast()的区别: signal只会唤醒一个被阻塞的goroutine, broadcast会唤醒所有goroutine
   *3.5 使用for{}作为检查: 检查状态--->等待通知--->被唤醒
   *3.6 wait方法主要做的四件事
        3.6.1 把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中
        3.6.2 解锁当前的条件变量基于的那个互斥锁。
        3.6.3 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个Wait方法的那行代码上。
        3.6.4 如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的 goroutine 就会继续执行后面的代码了。

4. Atomic
    4.1 支持数据类型
        4.1.1 常规类型: int32, int64, uint32, uint64, uintptr, unsafe-pointer
        4.1.2 自定义类型: Value
    4.2 支持操作: add, compare and swap(CAS), load, store, swap
    4.3 Atomic.Value (*重要)
        4.3.1 操作: store, load, swap, compareAndSwap
        4.3.2 Store数据二点原则: (1) 不能存nil (2) 只能存同类型数据
        4.3.3 原子值尽量不对外暴露, 访问权限至少包级私有化
        4.3.4 尽量不存引用类型的值
        4.3.5 可用public函数让外界间接使用它, 但原子值不传递到外界(值本身或值的指针)
        4.3.6 Store值时, 先进行类型判断, 否则系统会抛出panic
       *4.3.7 将原子值封装到结构体,见案例5
   *4.4 应用场景
        4.4.1 简单场景下,使用atomic: 非引用类型数据都挺适用, 例子:全局计数, 全局配置
                - 值类型:基本数据类型int系列, float系列, bool, string, 数组和结构体 struct
                - 引用类型:指针, slice切片, map, 管道chan, interface等都是引用类型
        4.4.2 复杂场景下,使用互斥锁

5. Once
   *5.1 同一个Once的Do方法永远只会执行一次,不论传的函数是什么
    5.1 通过字段done的值0或1,来标示Do方法是否被执行过
   *5.2 同时用"原子操作"和"互斥锁", 进行了双重检查
    5.3 Do方法执行时, 即使出现panic, 依然会认为已经执行过一次


6. Pool (**************************未搞明白, 暂时放一下**********************************)

    1. 基本功能、使用方式、适用场景和存在意义

    2. 临时对象:
        - 不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。
        - 它们也应该是无需被区分的，其中的任何一个值都可以代替另一个
    3. 临时对象池当作针对某种数据的缓存来用
    4. 方法: put()和get()
    5. Get()方法:
     - 从当前池中获取临时对象
     - 如果池中没有任何值, 调用当前池的New方法创建一个新值并返回
    6. fmt包使用pool
        var ppFree = sync.Pool{
         New: func() interface{} { return new(pp) },
        }


7. Map
    7.1 sync.Map是并发安全的字典
    7.2 如何保证sync.Map键和值类型的正确性
        7.2.1 编码时指定具体的数据类型
        7.2.2 使用反射reflect.Type动态设置
   *7.3 源码解析 (*****************************未搞明白, 暂时放一下*************************************)
    1. read和dirty字典分别的作用
    2. CRUD操作如何在这两个字典中的流程
    3. 两个字典如何互相转换
    4. read 和 dirty 互换是分两步走的。Load 的时候如果发现“不得不去 dirty 中查找”的情况已经有很多了，就会把 dirty 作为新的 read，然后把 dirty 置为 nil。之后，在 Store 的时候，
       如果发现健是新的，而且是对于新 read 的第一个新健（此时 dirty 必定为 nil），那么就重新初始化 dirty，然后把新 read 中的有效键一个一个地存入 dirty。

